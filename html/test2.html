<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>查詢分組發送器 (WebSocket版)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    textarea { width: 100%; height: 200px; }
    button { margin-top: 10px; padding: 10px 20px; }
    #results { margin-top: 20px; white-space: pre-wrap; background: #f4f4f4; padding: 10px; border-radius: 5px; }
    .status { margin-top: 10px; padding: 5px; border-radius: 3px; }
    .connecting { background: #fff3cd; }
    .connected { background: #d4edda; }
    .disconnected { background: #f8d7da; }
  </style>
</head>
<body>
  <h2>請輸入資料</h2>
  <textarea id="inputBox" placeholder="貼上你的內容..."></textarea>
  <br>
  <button onclick="handleSubmit()">開始分組並送出</button>

  <div id="status" class="status disconnected">狀態: 未連接</div>

  <h3>回應結果：</h3>
  <div id="results"></div>

  <script>
    let socket = null;
    const statusElement = document.getElementById('status');
    let currentIndex = 0;
    let groups = [];
    // Connect when page loads
    window.addEventListener('load', () => {
      connectWebSocket();
    });

    function connectWebSocket() {
      socket = new WebSocket('wss://ollamaui.nexlumis.com/fubon/sql-checker/ws/ai/query');

      socket.onopen = () => {
        statusElement.textContent = '狀態: 已連接';
        statusElement.className = 'status connected';
      };

      socket.onclose = () => {
        statusElement.textContent = '狀態: 已斷開';
        statusElement.className = 'status disconnected';
        // Attempt to reconnect after 5 seconds
        setTimeout(connectWebSocket, 5000);
      };

      socket.onerror = (error) => {
        statusElement.textContent = '狀態: 連接錯誤';
        statusElement.className = 'status disconnected';
      };

      socket.onmessage = (event) => {
        const resultDiv = document.getElementById('results');
         const match = event.data.match(/<Result>([\s\S]*?)<\/Result>/);
          const resultText = match ? match[1].trim() : '[無結果]';

          resultDiv.textContent += resultText + '\n\n';
         console.log("ws finish"+currentIndex);
        currentIndex++;

        if (currentIndex < groups.length) {
          console.log("ws start"+currentIndex);
          const query = createQueryPayload(groups[currentIndex]);
          socket.send(query);
        }
      };
    }

    function parseGroups(text) {
      const lines = text.trim().split(/\r?\n/);
      groups = [];
      let group = [];
      let selectCount = 0;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        group.push(line);

        if (/^select/i.test(line.trim())) {
          selectCount++;
        }

        if (selectCount === 2) {
          groups.push(group.join('\n'));
          group = [];
          selectCount = 0;
        }
      }

      if (group.length > 0) {
        groups.push(group.join('\n'));
      }

      return groups;
    }

    function createQueryPayload(query) {
      return `
        你是一位專業 SQL 審查員，具備查詢資料表的 DDL 結構與當前 DML 狀態的能力。
        1. 我將提供一段 SQL 腳本，格式如下：
          -- 人名1:人名2 需求
          -- Step 1:修改前查詢 (Before Update Query)
          [SELECT語句]
          -- Step 2: 執行語法 (Execution Statement)
          [多個DELETE/INSERT/UPDATE語句]
          -- Step 3: 修改後查詢 (After Update Query)
          [SELECT語句]
        2. 你必須利用MCP能力（即查詢相關表的DDL和查詢DML狀態）來輔助分析。
          - DDL：提供表結構，包括欄位名稱、資料類型、約束（主鍵、唯一鍵、外鍵、非空、檢查約束等）。
          - DML：提供Select 相關select語法當前在表中的查詢結果（例如，Step 1查詢結果，以及可能影響Step 2的其他資料）。
        3. 分析Step 2的執行語法，重點檢查以下兩類問題：
          a) 顯性失敗：執行時可能直接報錯，例如：
              - 插入的資料違反欄位長度限制（如：字串超過定義的長度）。
              - 插入或更新時違反唯一約束（重複鍵值）。
              - 更新或刪除時，條件匹配不到任何資料（但注意：更新0筆不一定算錯誤，需看需求，但這裡我們要求必須匹配到預期的筆數，如果Step 1查詢有提供預期修改的筆數，則需對比）。
              - 違反外鍵約束（如：插入的外鍵值在參考表中不存在）。
              - 資料類型不匹配（如：將字串插入數字欄位，但SQL通常會隱式轉換，需注意資料庫設定）。
              - 非空約束違反（插入NULL到不允許NULL的欄位）。
          b) 隱藏性失敗：執行時不會報錯，但可能導致資料不正確，例如：
              - 更新語句的WHERE條件不夠精確，導致更新了多筆資料，而預期只更新一筆（可通過Step1的查詢結果來判斷預期影響的行數）。
              - 刪除語句刪除了多餘的資料（超出預期範圍）。
              - 插入語句插入了重複的資料（但由於某些原因沒有觸發唯一約束？注意：通常有唯一約束就會觸發，但若表沒有設定唯一約束則不會，此時屬於邏輯錯誤）。
        4. 分析過程中，請逐一檢查Step 2中的每一條語句，並結合Step1的查詢結果（代表修改前的資料狀態）和相關表的DDL來判斷。
        5. 對於每一條Step2的語句，請給出：
          - 語句的潛在問題（顯性/隱藏性），若無問題則標記安全。
          - 若有問題，請說明原因，並盡可能提供修正建議。
        6. 注意：Step1的查詢結果是關鍵必須對給定的 Oracle 表執行 SELECT 查詢，它提供了當前資料的狀態。並藉由給定的 Oracle 表執行 SELECT 查詢結果模擬執行Step2的語句，並預測執行結果。
        7. 所有sql 語法中 DBUSERNEB. 皆可忽略 table name 也忽略它
        8. 請你僅輸出以下格式的審核報告（不要額外補充任何說明）：
        <Result>
        1.「语句编号与需求（人名1:人名2 需求）」
        2. 风险描述
        3. 修正建议
        <Result>
        ------------ 請開始分析以下SQL腳本：-------------------
        ${query}
      `;
    }

    async function handleSubmit() {
      const input = document.getElementById('inputBox').value;
      const resultDiv = document.getElementById('results');
      resultDiv.textContent = "";

      if (!socket || socket.readyState !== WebSocket.OPEN) {
        resultDiv.textContent = '錯誤: WebSocket未連接';
        return;
      }

      resultDiv.textContent = '處理中...\n';

      const groups = parseGroups(input);
      currentIndex = 0;
      if (groups.length > 0) {
        try {
          console.log("ws connect 0");
          const query = createQueryPayload(groups[currentIndex]);
          socket.send(query);
        } catch (error) {
          resultDiv.textContent += `錯誤處理：\n${groups[currentIndex]}\n錯誤：${error.message}\n\n`;
        }
      }
    }
  </script>
</body>
</html>