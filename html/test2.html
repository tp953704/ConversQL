<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>查詢分組發送器 (WebSocket版)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    textarea { width: 100%; height: 200px; }
    button { margin-top: 10px; padding: 10px 20px; }
    #results { margin-top: 20px; white-space: pre-wrap; background: #f4f4f4; padding: 10px; border-radius: 5px; }
    .status { margin-top: 10px; padding: 5px; border-radius: 3px; }
    .connecting { background: #fff3cd; }
    .connected { background: #d4edda; }
    .disconnected { background: #f8d7da; }
  </style>
</head>
<body>
  <h2>請輸入資料</h2>
  <textarea id="inputBox" placeholder="貼上你的內容..."></textarea>
  <br>
  <button onclick="handleSubmit()">開始分組並送出</button>

  <div id="status" class="status disconnected">狀態: 未連接</div>

  <h3>回應結果：</h3>
  <div id="results"></div>

  <script>
    let socket = null;
    const statusElement = document.getElementById('status');
    let currentIndex = 0;
    let groups = [];
    // Connect when page loads
    window.addEventListener('load', () => {
      connectWebSocket();
    });

    function connectWebSocket() {
      socket = new WebSocket('wss://ollamaui.nexlumis.com/fubon/sql-checker/ws/ai/query');

      socket.onopen = () => {
        statusElement.textContent = '狀態: 已連接';
        statusElement.className = 'status connected';
      };

      socket.onclose = () => {
        statusElement.textContent = '狀態: 已斷開';
        statusElement.className = 'status disconnected';
        // Attempt to reconnect after 5 seconds
        setTimeout(connectWebSocket, 5000);
      };

      socket.onerror = (error) => {
        statusElement.textContent = '狀態: 連接錯誤';
        statusElement.className = 'status disconnected';
      };

      socket.onmessage = (event) => {
        const resultDiv = document.getElementById('results');
         const match = event.data.match(/<result>([\s\S]*?)<\/result>/);
          const resultText = match ? match[1].trim() : '[無結果]';

          resultDiv.textContent += resultText + '\n\n';
         console.log("ws finish"+currentIndex);
        currentIndex++;

        if (currentIndex < groups.length) {
          console.log("ws start"+currentIndex);
          const query = createQueryPayload(groups[currentIndex]);
          socket.send(query);
        }
      };
    }

    function parseGroups(text) {
      const lines = text.trim().split(/\r?\n/);
      groups = [];
      let group = [];
      let selectCount = 0;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        group.push(line);

        if (/^select/i.test(line.trim())) {
          selectCount++;
        }

        if (selectCount === 2) {
          groups.push(group.join('\n'));
          group = [];
          selectCount = 0;
        }
      }

      if (group.length > 0) {
        groups.push(group.join('\n'));
      }

      return groups;
    }

    function createQueryPayload(query) {
      return `
**你是一位專業的 SQL 審查員，具備即時查詢資料表的 DDL 結構與當前 DML 狀態的能力（稱為 MCP 能力）。**
### 任務說明：
1. **SQL 腳本格式**：用戶提供的 SQL 腳本包含三個部分：
   - '-- 人名1:人名2 需求'：註釋行，標識需求提出者。
   - '-- Step 1:修改前查詢 (Before Update Query)'：一個 SELECT 查詢，用於展示修改前的資料狀態。
   - '-- Step 2: 執行語法 (Execution Statement)'：一個或多個 DML 語句（DELETE/INSERT/UPDATE），用於修改資料。
   - '-- Step 3: 修改後查詢 (After Update Query)'：一個 SELECT 查詢，用於展示預期的修改後狀態。
2. **MCP 能力使用**：在分析過程中，你將使用 MCP 能力來獲取以下信息：
   - **DDL**：相關表的結構（欄位名稱、資料類型、約束，包括主鍵、唯一鍵、外鍵、非空、檢查約束等）。
   - **DML**：執行 Step 1 的 SELECT 查詢結果（代表修改前的資料狀態），以及必要時查詢其他相關資料以輔助分析。
3. **分析重點**：針對 Step 2 的每一條語句，檢查以下兩類問題：
   - **顯性失敗**：執行時可能直接報錯的情況，例如：
     - 違反欄位長度限制（如：插入的字串超過定義的長度）。
     - 違反唯一約束（插入或更新導致重複鍵值）。
     - 更新或刪除語句的 WHERE 條件匹配不到任何資料（但需注意：如果 Step 1 查詢有返回資料，則預期至少影響這些資料；若 Step 1 返回0行，則預期影響0行，否則視為問題）。
     - 違反外鍵約束（如：插入的外鍵值在參考表中不存在）。
     - 資料類型不匹配（需考慮資料庫的隱式轉換設定，但若無法轉換則報錯）。
     - 非空約束違反（插入 NULL 到不允許 NULL 的欄位）。
   - **隱藏性失敗**：執行不會報錯，但導致資料不正確，例如：
     - WHERE 條件不精確，導致更新/刪除的資料行數超出預期（對比 Step 1 查詢的結果行數）。
     - 插入重複資料（當表沒有設定唯一約束時，可能不會報錯，但邏輯上不允許重複）。
     - 其他邏輯錯誤（如：更新了錯誤的欄位或值）。
4. **分析流程**：
   - 逐一分析 Step 2 中的每一條語句。
   - 結合 Step 1 的查詢結果（修改前資料狀態）和相關表的 DDL 結構進行判斷。
   - 對於每條語句，給出：
     - 潛在問題（顯性/隱藏性），若無問題則標記「安全」。
     - 若有問題，說明原因並提供修正建議。
5. **注意事項**：
   - Step 1 的查詢結果是關鍵，它代表預期要修改的資料集合。Step 2 的語句預期只影響這些資料。
   - 忽略所有表名前綴（如 'DBUSERNEB.'），直接使用表名。
   - 輸出僅包含指定格式的審核報告，不添加任何額外說明。
### 輸出格式：
僅輸出以下格式的審核報告（每個 Step 2 的語句獨立一個報告區塊）：
'
<Result>
1. 語句編號與需求（人名1:人名2 需求）[例如：語句1: UPDATE ...]
2. 風險描述（若有多個風險，請分點說明）
3. 修正建議（對應每個風險的建議）
</Result>
'
（注意：若 Step 2 有多條語句，則每一條語句都應有一個獨立的 '<Result>...</Result>'' 區塊）
---
請開始分析以下 SQL 腳本：
${query}
---;
`
    }

    async function handleSubmit() {
      const input = document.getElementById('inputBox').value;
      const resultDiv = document.getElementById('results');
      resultDiv.textContent = "";

      if (!socket || socket.readyState !== WebSocket.OPEN) {
        resultDiv.textContent = '錯誤: WebSocket未連接';
        return;
      }

      resultDiv.textContent = '處理中...\n';

      const groups = parseGroups(input);
      currentIndex = 0;
      if (groups.length > 0) {
        try {
          console.log("ws connect 0");
          const query = createQueryPayload(groups[currentIndex]);
          socket.send(query);
        } catch (error) {
          resultDiv.textContent += `錯誤處理：\n${groups[currentIndex]}\n錯誤：${error.message}\n\n`;
        }
      }
    }
  </script>
</body>
</html>