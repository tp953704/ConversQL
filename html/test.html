<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>查詢分組發送器</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    textarea { width: 100%; height: 200px; }
    button { margin-top: 10px; padding: 10px 20px; }
    #results { margin-top: 20px; white-space: pre-wrap; background: #f4f4f4; padding: 10px; border-radius: 5px; }
  </style>
</head>
<body>
  <h2>請輸入資料</h2>
  <textarea id="inputBox" placeholder="貼上你的內容..."></textarea>
  <br>
  <button onclick="handleSubmit()">開始分組並送出</button>

  <h3>回應結果：</h3>
  <div id="results"></div>

  <script>
    function parseGroups(text) {
      const lines = text.trim().split(/\r?\n/);
      const groups = [];
      let group = [];
      let selectCount = 0;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        group.push(line);

        if (/^select/i.test(line.trim())) {
          selectCount++;
        }

        if (selectCount === 2) {
          groups.push(group.join('\n'));
          group = [];
          selectCount = 0;
        }
      }

      // 加上最後一組（如果未滿2個select也保留） 
      if (group.length > 0) {
        groups.push(group.join('\n'));
      }

      return groups;
    }

    async function sendQuery(query) {
        
        const rq = `
        你是一個專業的SQL審查員，具有查詢資料庫DDL（數據定義語言）和當前DML（數據操作語言）狀態的能力。
        請根據以下提供的SQL腳本，逐步分析Step 2的執行語法（Execution Statement）是否存在問題。
        ### 分析流程
        步驟說明：
        1. 首先，你將獲得一個SQL腳本，格式如下：
        -- 人名1:人名2 需求
        -- Step 1:修改前查詢 (Before Update Query)
        [SELECT語句]
        -- Step 2: 執行語法 (Execution Statement)
        [多個DELETE/INSERT/UPDATE語句]
        -- Step 3: 修改後查詢 (After Update Query)
        [SELECT語句]
        2. 你必須利用MCP能力（即查詢相關表的DDL和當前DML狀態）來輔助分析。
        - DDL：提供表結構，包括欄位名稱、資料類型、約束（主鍵、唯一鍵、外鍵、非空、檢查約束等）。
        - DML：提供當前表中相關資料的狀態（例如，Step 1查詢結果，以及可能影響Step 2的其他資料）。
        3. 分析Step 2的執行語法，重點檢查以下兩類問題：
        a) 顯性失敗：執行時可能直接報錯，例如：
            - 插入的資料違反欄位長度限制（如：字串超過定義的長度）。
            - 插入或更新時違反唯一約束（重複鍵值）。
            - 更新或刪除時，條件匹配不到任何資料（但注意：更新0筆不一定算錯誤，需看需求，但這裡我們要求必須匹配到預期的筆數，如果Step 1查詢有提供預期修改的筆數，則需對比）。
            - 違反外鍵約束（如：插入的外鍵值在參考表中不存在）。
            - 資料類型不匹配（如：將字串插入數字欄位，但SQL通常會隱式轉換，需注意資料庫設定）。
            - 非空約束違反（插入NULL到不允許NULL的欄位）。
        b) 隱藏性失敗：執行時不會報錯，但可能導致資料不正確，例如：
            - 更新語句的WHERE條件不夠精確，導致更新了多筆資料，而預期只更新一筆（可通過Step1的查詢結果來判斷預期影響的行數）。
            - 刪除語句刪除了多餘的資料（超出預期範圍）。
            - 插入語句插入了重複的資料（但由於某些原因沒有觸發唯一約束？注意：通常有唯一約束就會觸發，但若表沒有設定唯一約束則不會，此時屬於邏輯錯誤）。
        4. 分析過程中，請逐一檢查Step 2中的每一條語句，並結合Step1的查詢結果（代表修改前的資料狀態）和相關表的DDL來判斷。
        5. 對於每一條Step2的語句，請給出：
        - 語句的潛在問題（顯性/隱藏性），若無問題則標記安全。
        - 若有問題，請說明原因，並盡可能提供修正建議。
        6. 注意：Step1的查詢結果是關鍵，它提供了當前資料的狀態。你需要模擬執行Step2的語句，並預測執行結果。
        7. 所有sql 語法中 DBUSERNEB. 皆可忽略 table name 也忽略它
        8. 最後給予情感反饋
        if 所有语句无风险:
            生成 "{人名1} 专属鼓励"：  
                ✓ 10字以内极度吹捧的句子  
                ✓ 添加至少3个庆祝emoji  
                ✓ 示例："代码之神！✨🚀👑"  
        else:
            生成 "{人名1} 专属安慰"：  
                ✓ 先明确错误类型和位置  
                ✓ 暖心句子 + 技术支援承诺  
                ✓ 示例："小失误啦～马上帮你解决！💪😊"
        ### 审核报告
        | 语句人名1:人名2 需求  | 风险类型 | 风险描述                  | 修正建议              |  
        |---------|---------|--------------------------|---------------------|  
        | 1       | 显性    | 字段长度溢出：varchar(10) ← '超长文本' | 截断或修改 DDL      |  

        ### 情感反馈
        {根据检查结果生成的专属鼓励或安慰}


        請開始分析以下SQL腳本：
        ${query}
        `;
        const response = await fetch('http://127.0.0.1:8000/api/ai/query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query: rq })
        });
      const data = await response.json(); // ← 這裡解析 JSON
        const cleaned = data.response.replace(/<think>.*?<\/think>/gs, '').trim();
        return cleaned;
    }

    async function handleSubmit() {
      const input = document.getElementById('inputBox').value;
      const resultDiv = document.getElementById('results');
      resultDiv.textContent = '處理中...\n';

      const groups = parseGroups(input);
      for (const group of groups) {
        try {
          
          const cleaned = await sendQuery(group);
          resultDiv.textContent += `輸入：\n${group}\n回應：\n${cleaned}\n\n`;
        } catch (error) {
          resultDiv.textContent += `錯誤處理：\n${group}\n錯誤：${error.message}\n\n`;
        }
      }
    }
  </script>
</body>
</html>
